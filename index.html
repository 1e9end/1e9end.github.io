<!DOCTYPE html>
<!-- 
    Personal Portfolio website
    > CSA (aka IAmLegend)

    [Display Project] Raymarching Primitives
    Sphere raymarched and rendered with webGL
    Initalizer code used with LegendWebGL1.0.js, my webGL Library

    [Info] 
    Rendered with canvas 2d context 
    Links took so long lol
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSA's site :3</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #2D {
            position: relative;
            font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
    </style>
</head>
<body> 
    <canvas id = "canvas">
        Your browser does not currently support HTML5. <br> Please try Chrome, Firefox, or Edge.
    </canvas>
    <canvas id = "2D">

    </canvas>
</body>
<script id = "vts" type = "vertex-shader">
    attribute vec4 position;
    precision highp float;
    
    void main(){
        gl_Position = position;
    }
</script>
<script id ="fts" type = "fragment-shader">
    precision highp float;
    uniform vec2 res;
    uniform float time;
    
    float PI = 3.14;
    float EPSILON = 0.001;
    // rotation matrix around origin
    vec3 rotate(vec3 p, vec3 r){
        // d --> r
        r.x *= PI/180.0;
        r.y *= PI/180.0;
        r.z *= PI/180.0;
        mat3 xRot = mat3 (1,0,0,
                          0,cos(r.x),-sin(r.x),
                          0,sin(r.x), cos(r.x));
        mat3 yRot = mat3 (cos(r.y),0,sin(r.y),
                          0,1,0,
                          -sin(r.y),0,cos(r.y));
        mat3 zRot = mat3 (cos(r.z),-sin(r.z),0,
                          sin(r.z),cos(r.z),0,
                          0,0,1);
        return xRot * yRot * zRot * p;
    }
    //again from http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/
    float pyramidDE(vec3 p){
        // lol i actually have no idea what these vars do but the values look ok so
        float scale = 1.75;
        float offset = 2.5;
        for (int n = 0; n < 16; ++n) {
            if(p.x + p.y < 0.0){ 
                p.xy = - p.yx;
            } 
            if(p.x + p.z < 0.0){ 
                p.xz = - p.zx;
            } 
            if(p.y + p.z < 0.0){ 
                p.zy = - p.yz;
            } 
            p = p * scale - offset*(scale - 1.0);
        }
    
        return length(p) * pow(scale, - 16.0);
    }
    vec3 approxNormal(vec3 p)
    {
    	return normalize(vec3(
    		pyramidDE(p + vec3(EPSILON, 0, 0)) - pyramidDE(p - vec3(EPSILON, 0, 0)),
    		pyramidDE(p + vec3(0, EPSILON, 0)) - pyramidDE(p - vec3(0, EPSILON, 0)),
    		pyramidDE(p + vec3(0, 0, EPSILON)) - pyramidDE(p - vec3(0, 0, EPSILON))));
    }
    // woah so shadows raymarch towards the light from the intersection and see if theres collision cool :o
    float hardshadow (vec3 origin, vec3 direction, float smoothness, float time){
        float distance = EPSILON;
        for (float iters = 0.0; iters < 200.0; ++iters){
            vec3 pos = origin + distance * direction;
            vec3 rPos = rotate(pos, vec3(0.0, mod(time, 360.0) * 30.0 + 45.0, 55.0));
            float nextDistance = pyramidDE(rPos);
            distance += nextDistance;
            if (abs(nextDistance) < EPSILON){
                return distance * .5;
            }
        }
        return 1.0;
    }
    vec3 raymarch(vec3 origin, vec3 direction, vec3 light, float time){
        float distance = 0.0;
        for (float iters = 0.0; iters < 200.0; ++iters){
            vec3 pos = origin + distance * direction;
            vec3 rPos = rotate(pos, vec3(0.0, mod(time, 360.0) * 30.0 + 45.0, 55.0));
            float nextDistance = pyramidDE(rPos);
            distance += nextDistance;
            if (abs(nextDistance) < EPSILON){ 
                vec3 normal = approxNormal(pos);
                float diffuse = max(0.0, dot(normal, light)); 
                // https://learnopengl.com/Lighting/Basic-Lighting
                vec3 reflected = reflect(direction, normal);
                float specular = pow(max(dot(reflected, light), 0.0), 16.0); 
                float shade = diffuse * 0.7 + specular * 0.3; 
                vec3 ambient = vec3(1.0, 1.0, 1.0);
                return shade * ambient * hardshadow(pos, light, .2, time);
            }
            if (distance > 100.0){
                break;
            }
        }
        // Background blue
        return vec3(0.0, 0.0, 0.5);
    }
    void main(){
        // window relative -> clip space
        vec2 uv = gl_FragCoord.xy * res - 1.0;
        vec3 center = vec3(0.3, -0.3, 0.0);
        // directional light
        vec3 light = normalize(vec3(-1.0, 0.8, -1.0)); 
        gl_FragColor = vec4(raymarch(vec3(0.0, 0.0, -6.0), normalize(vec3(uv, 0.0) - vec3(0.0, 0.0, -1.0)), light, time), 1.0);
    }
</script>
<script src = "https://cdn.jsdelivr.net/gh/CSA-Programming/LegendGL/LegendWebGL1.0.js"></script><!-- My WebGL library -->
<script src = "main.js"></script>
<script></script>
</html>
