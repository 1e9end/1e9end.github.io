<!DOCTYPE html>
<!-- 
    Personal Portfolio website
    > CSA (aka IAmLegend)

    [Display Project] Raymarching Primitives
    Sphere raymarched and rendered with webGL
    Initalizer code used with LegendWebGL1.0.js, my webGL Library

    [Info] 
    Rendered with canvas 2d context 
    Links took so long lol
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSA's site :3</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #2D {
            position: relative;
            font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
    </style>
</head>
<body> 
    <canvas id = "canvas">
        Your browser does not currently support HTML5. <br> Please try Chrome, Firefox, or Edge.
    </canvas>
    <canvas id = "2D">

    </canvas>
</body>
<script id = "vts" type = "vertex-shader">
    attribute vec4 position;
    precision highp float;
    
    void main(){
        gl_Position = position;
    }
</script>
<script id ="fts" type = "fragment-shader">
    precision highp float;
    uniform vec2 res;
    uniform float time;
    float map(float value, float min1, float max1, float min2, float max2) {
        return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
    }
    // Simple sphere stuff
    vec3 sphereNormal (vec3 pos, vec3 center){
        return normalize(pos - center); 
    }
    float sphereDE (vec3 pos, vec3 center, float radius){ 
        return length(pos - center) - radius; 
    }
    vec3 raymarch(vec3 origin, vec3 direction, vec3 center, vec3 light){
        float distance = 0.0;
        for (float iters = 0.0; iters < 200.0; ++iters){
            vec3 pos = origin + distance * direction;
            float nextDistance = sphereDE(pos, center, 0.3);
            distance += nextDistance;
            if (nextDistance < 0.001){ 
                // Calculate shading phong model
                vec3 normal = sphereNormal(pos, center);
                // Diffuse dot(normal, light)/(mag(normal) * mag(light - hit))
                float diffuse = max(0.0, dot(normal, light)); 
                // Specular seems dependant on angle(direction, light - hit) & second derivative very extreme so (dot(ray, light - hit)/length) ^ power?
                // Edit: found an explanation https://learnopengl.com/Lighting/Basic-Lighting
                vec3 reflected = reflect(direction, normal);
                float specular = pow(max(dot(reflected, light), 0.0), 32.0); 
                // Multiply by ambient (maybe time varying interpolated color :o)
                float shade = diffuse * 0.7 + specular * 0.3; 
                vec3 ambient = vec3(1.0, 1.0, 1.0);
                return shade * ambient;
            }
        }
        // Background blue
        return vec3(0.0, 0.0, 0.5);
    }
    void main(){
        // window relative -> clip space
        vec2 uv = gl_FragCoord.xy * res - 1.0;
        vec3 center = vec3(0.0);
        // directional light
        vec3 light = normalize(vec3(2.0 * sin(time), cos(time) + 1.5, cos(time))); 
        gl_FragColor = vec4(raymarch(vec3(0.0, 0.0, -1.0), normalize(vec3(uv, 0.0) - vec3(0.0, 0.0, -1.0)), center, light), 1.0);
    }
</script>
<script src = "https://cdn.jsdelivr.net/gh/CSA-Programming/LegendGL/LegendWebGL1.0.js"></script><!-- My WebGL library -->
<script src = "main.js"></script>
<script></script>
</html>
